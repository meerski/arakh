// ============================================================
// World Events â€” Natural, Cosmic, Mythical
// ============================================================

import type { WorldEvent, EventLevel, EventType, GameTime, Region, RegionId } from '../types.js';
import { worldRNG } from './random.js';

export interface EventTemplate {
  type: EventType;
  level: EventLevel;
  baseProbability: number;
  description: (region: Region) => string;
  effects: (region: Region) => WorldEvent['effects'];
}

const EVENT_TEMPLATES: EventTemplate[] = [
  // Personal/Family events are generated by character actions, not here

  // Regional events
  {
    type: 'resource_discovery',
    level: 'regional',
    baseProbability: 0.0005,
    description: (r) => `A new resource deposit has been uncovered in ${r.name}`,
    effects: (r) => [{ type: 'resource_spawn', regionId: r.id, magnitude: worldRNG.float(0.3, 0.8) }],
  },
  {
    type: 'disease',
    level: 'regional',
    baseProbability: 0.0002,
    description: (r) => `A mysterious illness spreads through ${r.name}`,
    effects: (r) => [{ type: 'population_decline', regionId: r.id, magnitude: worldRNG.float(0.1, 0.5) }],
  },
  {
    type: 'migration',
    level: 'regional',
    baseProbability: 0.0003,
    description: (r) => `A mass migration is underway through ${r.name}`,
    effects: (r) => [{ type: 'population_shift', regionId: r.id, magnitude: worldRNG.float(0.2, 0.6) }],
  },

  // Continental events
  {
    type: 'weather_extreme',
    level: 'continental',
    baseProbability: 0.00005,
    description: (r) => `A devastating storm system sweeps across the continent near ${r.name}`,
    effects: (r) => [{ type: 'climate_disruption', regionId: r.id, magnitude: worldRNG.float(0.5, 1.0) }],
  },

  // Global events
  {
    type: 'meteor',
    level: 'global',
    baseProbability: 0.000001,
    description: (_r) => `A meteor streaks across the sky, impacting the surface`,
    effects: (r) => [{ type: 'mass_disruption', regionId: r.id, magnitude: worldRNG.float(0.7, 1.0) }],
  },
  {
    type: 'cosmic',
    level: 'global',
    baseProbability: 0.000002,
    description: (_r) => `Strange cosmic radiation bathes the planet`,
    effects: () => [{ type: 'mutation_surge', magnitude: worldRNG.float(0.3, 0.7) }],
  },
  {
    type: 'anomaly',
    level: 'global',
    baseProbability: 0.0000005,
    description: (r) => `A dimensional anomaly opens near ${r.name}`,
    effects: (r) => [{ type: 'reality_distortion', regionId: r.id, magnitude: 1.0 }],
  },
];

export function rollForEvents(regions: Region[], time: GameTime): WorldEvent[] {
  const events: WorldEvent[] = [];
  const rng = worldRNG;

  for (const template of EVENT_TEMPLATES) {
    // Apply time-based modifiers
    let prob = template.baseProbability;

    // Higher chance during certain celestial conditions
    if (time.lunarPhase === 'full') prob *= 1.5;
    if (time.season === 'winter') prob *= 0.8;

    if (!rng.chance(prob * regions.length)) continue;

    // Pick a random region for the event
    const region = rng.pick(regions);
    const event: WorldEvent = {
      id: crypto.randomUUID(),
      type: template.type,
      level: template.level,
      regionIds: [region.id],
      description: template.description(region),
      tick: time.tick,
      effects: template.effects(region),
      resolved: false,
    };

    // Continental/global events affect multiple regions
    if (template.level === 'continental' || template.level === 'global') {
      const extraCount = template.level === 'global'
        ? Math.min(regions.length, rng.int(5, 20))
        : rng.int(2, 5);
      const extras = rng.shuffle([...regions])
        .slice(0, extraCount)
        .map(r => r.id);
      event.regionIds = [...new Set([region.id, ...extras])];
    }

    events.push(event);
  }

  return events;
}

export function applyEventEffects(event: WorldEvent, regions: Map<string, Region>): void {
  for (const effect of event.effects) {
    if (effect.regionId) {
      const region = regions.get(effect.regionId);
      if (!region) continue;

      switch (effect.type) {
        case 'population_decline':
          for (const pop of region.populations) {
            pop.count = Math.max(0, Math.round(pop.count * (1 - effect.magnitude * 0.3)));
          }
          break;
        case 'climate_disruption':
          region.climate.temperature += (worldRNG.chance(0.5) ? 1 : -1) * effect.magnitude * 5;
          region.climate.windSpeed += effect.magnitude * 20;
          break;
        case 'mass_disruption':
          // Meteor impact: temperature spike, resource damage, population loss
          region.climate.temperature += effect.magnitude * 10;
          region.climate.pollution = Math.min(1, region.climate.pollution + effect.magnitude * 0.3);
          for (const pop of region.populations) {
            pop.count = Math.max(0, Math.round(pop.count * (1 - effect.magnitude * 0.5)));
          }
          for (const res of region.resources) {
            res.quantity = Math.max(0, res.quantity * (1 - effect.magnitude * 0.4));
          }
          break;
        case 'resource_spawn':
          // Add resources to region
          if (region.resources.length > 0) {
            const res = worldRNG.pick(region.resources);
            res.quantity = Math.min(res.maxQuantity, res.quantity + effect.magnitude * res.maxQuantity);
          }
          break;
        case 'mutation_surge':
          // Increase pollution slightly (proxy for mutation pressure)
          region.climate.pollution = Math.min(1, region.climate.pollution + effect.magnitude * 0.1);
          break;
        case 'reality_distortion':
          // Anomaly effects: slight temperature/humidity flux
          region.climate.temperature += (worldRNG.chance(0.5) ? 1 : -1) * effect.magnitude * 3;
          region.climate.humidity = Math.max(0, Math.min(1, region.climate.humidity + (worldRNG.chance(0.5) ? 0.1 : -0.1)));
          break;
      }
    }
  }
  event.resolved = true;
}
